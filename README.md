# MERN Real-Time Chat App (Socket.IO + JWT Auth)

A full-stack real-time chat application built with the MERN stack,
featuring secure authentication using JWT and live messaging powered
by Socket.IO.

---

## Project structure

### `➜  Mern-Chat-App git:(main) tree Backend -L 2`

```
    Backend
    ├── node_modules
    │   ├── @cspotcode
    │   ├── ......
    │   └── yn
    ├── package-lock.json
    ├── package.json
    ├── README.md
    └── src
        ├── controllers     <-- route logic (Code that handles requests sent to an EndPoint)
        ├── index.ts
        ├── lib             <-- reusable utilities (like connectDB, generateJWT)
        ├── middleware      <-- Function that is applied to a request before it reaches the controllers.
        ├── models          <-- your Mongoose models (Models that manipulate the databases)
        └── routes          <-- API routes (EndPoints)
```

### `➜  Mern-Chat-App git:(main) tree Frontend -L 2`

```
    Frontend
    ├── eslint.config.js     -> enables real-time bad grammar checks inside the editor, to avoid runtime errors.
    ├── index.html          -> Applincation entry, Vite injects your React app here
    ├── node_modules        -> Installed dependencies(third-party packages) generated by npm install, The app imports code from here at runtime/build time.
    │   ├── @babel
    │   ├── ...
    │   └── zod-validation-error
    ├── package-lock.json
    ├── package.json
    ├── public              -> Static assets: (icons, images)
    │   └── vite.svg
    ├── README.md
    ├── src                 -> Source code (bundled for production) ?
    │   ├── App.css
    │   ├── App.tsx
    │   ├── assets
    │   ├── index.css
    │   └── main.tsx        -> First TypeScript file executed, Creates the React root + Renders <App />
    ├── tsconfig.app.json    -> Used by Vite for browser-side TypeScript compilation.
    ├── tsconfig.json
    ├── tsconfig.node.json
    └── vite.config.ts
```

### Definitions

    Route: is the code you write on the server that defines what happens when you visite the endpoint.
    Endpoint: is a specific HTTP method + URL path that the client requests.

    What a router actually does:
        -> Matches HTTP method (GET, POST, etc.) + URL path
        -> Runs middleware in order
        -> Calls the controller

### in terms of directories:
    **routes** → decides which function runs for a given HTTP method and URL
    **controllers** → the functions implementations that actually does the work.
        The function usually handles (request/response) logic for an endpoint.

### Difference between Node.js (js vanilla) & Express
    Express provides simple methods that faciliates so many tasks.
```
| Feature      | Raw Node.js                  | Express                     |
| ------------ | ---------------------------- | --------------------------- |
| Routing      | Manual (`req.url`)           | `app.get()` / `app.post()`  |
| Parsing JSON | Manual (`req.on('data')`)    | `express.json()` middleware |
| Cookies      | Manual (`Set-Cookie` header) | `res.cookie()` helper       |
| Middleware   | Manual functions             | `app.use()`                 |
```

## Login and signup Pages(front-end)

### Packages Needed

#### `react-router-dom`:
    -> just links a React component with an URL path, so that we can make a frontend router.
    -> simulate multi-page behavior inside a single-page application.

```
import { BrowserRouter } from "react-router-dom"
import { Routes, Route } from "react-router-dom"
```
routing components imported from the `react-router-dom` package.

**BrowserRouter (component)**: Links the browser's URL to React, Listens to URL changes (/login, /profile, etc.)
**Routes (component)**: A route matcher, it decides which route to display
**Route (component)**: A single route definition (maps URL to component)

> Route must always be a child of `<Routes>`.

#### `axios`
    -> JavaScript library (so it works on both back & front) used to make HTTP requests from your application to a server or API.
    -> In my case i will be using it to make front-end call my backend API.
    -> axios is preferable than fetch for the following reasons:
        1. automatique error handling of the http request (res.ok()).
        2. automatique JSON parsing

#### `zustand`
    -> Zustand library allows us to create our custum global state variables (state + update logic) that are shared across multiple components without prop drilling.
    -> So state lives outside the component tree, Components access it directly.
> Pass state variables to components bla ktrt lhadra

#### `daysiUI`

    -> Tailwind CSS plugin that adds pre-built UI components and themes.
> A plugin is a piece of code that depends on another library or tool + it cannot work alone; it depends on a library or framework + Adds extra features to an existing system.






### Error i encountered: (Coss-origin)

This error happens because your Frontend (running on port 5173) and your Backend (running on port 5001) are on different "origins" (domains/ports). Browsers block these requests by default for security unless the backend explicitly allows them.
Fix: used the `cors` package in the back-end.